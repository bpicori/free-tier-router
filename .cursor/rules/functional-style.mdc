---
description: Enforce functional-first design with explicit state and side effects
alwaysApply: true
---

# Functional Programming Style

This codebase follows a **functional-first architecture**.

Prefer **pure functions, immutable data, and composition** over class-based OOP.
Classes are allowed **only when required by external frameworks or libraries**
(e.g. React components, ORMs, DI containers).

---

## Core Principles

### 1. Functional Core, Imperative Shell
- Keep **business logic pure**
- Isolate side effects (I/O, database, network, time, randomness) at system boundaries

---

### 2. Functions Over Classes
- Prefer standalone functions over classes and class methods
- Avoid classes that encapsulate mutable state
- Do not model domain logic as “services”, “managers”, or “controllers”

---

### 3. Explicit State and Dependencies
- Pass state explicitly as function arguments
- Return new state instead of mutating inputs
- Inject dependencies via parameters, not constructors or globals

---

### 4. Immutability by Default
- Do not mutate objects, arrays, or function arguments
- Use object/array spreading or functional helpers to create new values

---

### 5. Composition Over Control Flow
- Build behavior by composing small, focused functions
- Prefer `map`, `filter`, `reduce`, and pipelines over loops and deeply nested conditionals

---

### 6. Types Describe Data, Not Behavior
- Use `type` aliases or `interface`s for data shapes
- Avoid class-based models for domain entities
- Prefer union types over booleans or nullable values

---

## Examples

### ❌ Avoid Class-Based Services
```ts
class UserService {
  constructor(private db: Database) {}

  async getUser(id: string) {
    return this.db.query(
      'SELECT * FROM users WHERE id = ?',
      [id]
    );
  }
}
````

### ✅ Prefer Functional Dependency Injection

```ts
const getUser = async (
  db: Database,
  id: string
): Promise<User | null> =>
  db.query('SELECT * FROM users WHERE id = ?', [id]);
```

---

### ❌ Avoid Mutation

```ts
function addItem(cart: Cart, item: Item) {
  cart.items.push(item);
  return cart;
}
```

### ✅ Return New Data

```ts
const addItem = (cart: Cart, item: Item): Cart => ({
  ...cart,
  items: [...cart.items, item],
});
```

---

### ❌ Avoid Hidden Internal State

```ts
class Counter {
  private count = 0;
  increment() { this.count++; }
}
```

### ✅ Make State Explicit

```ts
type CounterState = { count: number };

const increment = (state: CounterState): CounterState => ({
  count: state.count + 1,
});
```

---

### ❌ Avoid Nullable Results

```ts
function findUser(id: string): User | null {
  return db[id] ?? null;
}
```

### ✅ Prefer Explicit Result Types

```ts
type Result<T> =
  | { ok: true; value: T }
  | { ok: false; error: string };

const findUser = (id: string): Result<User> =>
  db[id]
    ? { ok: true, value: db[id] }
    : { ok: false, error: 'User not found' };
```

---

## Allowed Exceptions

Classes are acceptable when:

* Required by framework APIs (e.g. React components, NestJS controllers)
* Interfacing with third-party libraries that enforce class usage
* Encapsulating **pure data only** (no mutable state, no behavior)

When classes are unavoidable:

* Keep them thin
* Do not embed business logic
* Delegate logic to pure functions
